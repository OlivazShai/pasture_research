---
title: "Transportation Costs"
author: "Shai Vaz"
date: "May 2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
# Data Wrangling
library(dplyr)
library(readr)
library(tidyr)
library(stringr)
library(readxl)
library(purrr)

# Graphics
library(ggplot2)

# Geographic
library(sf)
library(terra)
```

# Importing

## Serialised data

```{r}
bulk_read_rds(
  amc_1991_2022,
  conservation_units,
  indigenous_lands
  )
```

## Transportation Costs

```{r}
tc <- rast(
  x = "../Inputs/cost_raster_raster_proj.tif"
  )
```

## AMC terra vector

```{r}
amc_tr <- amc_1991_2022 |> 
  # match crs with raster
  st_transform(
    crs(tc)
  ) |>
  # save with terra
  vect()
```

## Conservation Units

There are two groups of Conservation Units. Integral Protection (PI) areas have the objective of preserving nature, with only the indirect use of its natural resources being permitted. Sustainable Use (US) areas have the aim of reconciling nature conservation with sustainable use of natural resources.

```{r}
conservation_units_tr <- conservation_units |>
  # filter only Integral Protection
  filter(
    group == "PI"
  ) |> 
  # match crs with raster
  st_transform(
    crs(tc)
  ) |>
  # save with terra
  vect()
```

## Indigenous Lands

```{r}
indigenous_lands_tr <- indigenous_lands |>
  # match crs with raster
  st_transform(
    crs(tc)
  ) |>
  # save with terra
  vect()
```

# Transportation costs per AMC

I use a raster of quality adjusted transportation cost to major ports, developed by Rafael Araujo.

## Removing protected areas

Here I'll remove conservation units and indigenous lands from the cost raster.

```{r}
tc_unprotected <- tc |> 
  # cut conservation units
  mask(
    conservation_units_tr,
    inverse = TRUE
  ) |> 
  # cut indigenous lands
  mask(
    indigenous_lands_tr, 
    inverse = TRUE
  )
```

## Masking raster

```{r, eval=FALSE}
tc_by_amc <- terra::extract(
  # extract from raster
  tc_unprotected,
  # at locations defined by the vector
  amc_tr, 
  fun = mean, 
  na.rm = TRUE,
  touches = TRUE,
  bind = TRUE) |> 
  # return to sf format
  st_as_sf() |> 
  rename(
    transport_cost = cost_raster_raster_proj
  ) |> 
  # reverse CRS to standard
  st_transform(
    st_crs(amc_1991_2022)
  ) 
```

## Vers√£o com varias coisas

```{r}
# Define the custom function for the summary statistics
my_summary <- function(x, na.rm) {
  # Calculate mean, median, mean of the 1st quartile, and mean of the 4th quartile
  q1 <- quantile(x, 0.25, na.rm = na.rm)
  q4 <- quantile(x, 0.75, na.rm = na.rm)
  
  c(
    mean = mean(x, na.rm = na.rm),
    median = median(x, na.rm = na.rm),
    q1_mean = mean(x[x <= q1], na.rm = na.rm),
    q4_mean = mean(x[x >= q4], na.rm = na.rm)
  )
}

# Use the custom function with terra::extract
tc_by_amc <- terra::extract(
  tc_unprotected,
  amc_tr, 
  fun = my_summary, 
  na.rm = TRUE,
  touches = TRUE,
  bind = TRUE
) |> 
  # Return to sf format
  st_as_sf() 


  rename(
    mean_transport_cost = mean,
    median_transport_cost = median,
    q1_mean_transport_cost = q1_mean,
    q4_mean_transport_cost = q4_mean
  ) |> 
  # Reverse CRS to standard
  st_transform(
    st_crs(amc_1991_2022)
  )

```

STOP

## Map

```{r}
ggplot() +
  geom_sf(
    data = transport_cost_muni,
    aes(
      geometry = geometry,
      fill = transport_cost
      ),
    color= NA
    ) +
  theme_minimal() +
  theme(
    axis.title=element_blank(),
    axis.text=element_blank(),
    axis.ticks=element_blank()
    )
```

## Generate RDS

```{r}
bulk_write_rds()
```

# Distance to slaughterhouses

## Reading

```{r}
sh <- st_read(
  "../Inputs/slaughterhouses/limites_frigorificos_2021.shp",
  quiet = T
  ) |> 
  st_transform(
    crs = st_crs(municipalities)
  )
```

```{r}
sh_active <- sh |> 
  filter(
    situacao == "Ativo"
  )
```

## Plot points

```{r}
ggplot() +
  geom_sf(
    data = municipalities,
    aes(geometry = geom),
    color = "darkgrey",
    fill = NA
    ) +
  theme_minimal() +
  theme(
    axis.title=element_blank(),
    axis.text=element_blank(),
    axis.ticks=element_blank()
    ) +
  geom_sf(
    data = sh |> 
      filter() ,
    aes(
      geometry = geometry,
      color = situacao
    )
  )
```

```{r}
sh_distance <-  municipalities |>
  mutate(
    centroid = st_centroid(geom)
  ) |>
  mutate(
    nearest_point_index = st_nearest_feature(centroid, sh_active)
  ) |>
  mutate(
    distance_to_sh = st_distance(
      centroid, 
      sh_active[nearest_point_index, ], 
      by_element = TRUE)
  ) |> 
  mutate(
    distance_to_sh = as.numeric(distance_to_sh)/1000 #change to km
  ) |>
  select(-nearest_point_index) 
```

```{r}
ggplot() +
  geom_sf(
    data = sh_distance |> 
      filter(code_state %in% amazon_states),
    aes(
      geometry = geom,
      fill = distance_to_sh
      ),
    color = NA
    ) +
  theme_minimal() +
  theme(
    axis.title=element_blank(),
    axis.text=element_blank(),
    axis.ticks=element_blank()
    )
```

# Market Access

```{r}
market_access <- read_csv(
  file = "../Inputs/Market_access.csv",
  col_types = c("c","c","n", "n","n","l")
  )
```

For now, we'll simply repeat data from 2000's to each municipality, using the AMCs.

```{r}
market_acess_by_muni <- left_join(
  # AMCs in 1991 by municipalities
  amc_1991_by_muni |> 
    as_tibble() |> 
    select(code_amc, muni),
  # Market access by AMC
  market_access |> 
    select(amc, "2000"),
  by = join_by("code_amc" == "amc")
  ) |> 
  mutate(
    market_access_2000 = `2000`/max(`2000`, na.rm = TRUE)*100
  ) |> 
  select(-c("2000"))
```

GET BY NEW AMC
